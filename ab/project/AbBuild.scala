import sbt._
import sbt.Keys._

object AbBuild extends Build {
  val scalazVersion = "7.1.0"

  val customResolvers = List(
    "tpolecat"  at "http://dl.bintray.com/tpolecat/maven")

  val deps = List(
    "org.scalaz" %% "scalaz-core" % scalazVersion,
    "org.scalaz" %% "scalaz-concurrent" % scalazVersion,
    "org.scodec" %% "scodec-bits" % "1.0.5",
    "org.scodec" %% "scodec-core" % "1.7.0",
    "org.tpolecat" %% "atto-core"  % "0.4.1", 
    "org.specs2" %% "specs2" % "2.4.15" % "test",
    "org.scalacheck" %% "scalacheck" % "1.12.2" % "test"
  )

  // from http://tpolecat.github.io/2014/04/11/scalac-flags.html
  val pedanticScalac = Seq(
    "-deprecation",           
    "-encoding", "UTF-8",       
    "-feature",                
    "-language:existentials",
    "-language:higherKinds",
    "-language:implicitConversions",
    "-unchecked",
    "-Xfatal-warnings",       
    "-Xlint",
    "-Yno-adapted-args",       
    "-Ywarn-dead-code",        
    "-Ywarn-numeric-widen",   
    "-Ywarn-value-discard",
    "-Xfuture",
    "-Ywarn-unused-import"     
  )

  val autoGenerated = Def.task {
    def createAlphaNum(file: File): Seq[File] = {
      val name = "AlphaNum"

      def className(c: Char): String = {
        if      (c.isDigit) "Digit" + c
        else if (c.isLower) "Lower" + c.toUpper
        else                "Upper" + c.toUpper
      }

      val chars = ('a' to 'z') ++ ('A' to 'Z') ++ ('0' to '9')

      def log2(i: Int): Int = math.ceil(math.log(i) / math.log(2)).toInt

      val Size = log2(chars.size)

      def binaryString(i: Int): String = {
        val string = i.toBinaryString
        val nPad = Size - string.size
        ("0" * nPad) + string
      }

      val string = 
       s"""|package ab.model
           |
           |import scalaz._, Scalaz._
           |import scodec._
           |import scodec.bits._
           |
           |/*
           | * Autogenerated by AbBuild.scala
           | */
           |sealed abstract class AlphaNum
           |object AlphaNum {
           |  implicit val encoder: Encoder[AlphaNum] = new Encoder[AlphaNum] {
           |    override def sizeBound = SizeBound.exact(${Size})
           |    
           |    override def encode(a: AlphaNum): Attempt[BitVector] = a match {
           |""".stripMargin('|') +
        (0 until chars.size).map { i =>
          s"      case ${className(chars(i))} => Attempt.successful(bin" + '"' + binaryString(i) + "\")"
        }.mkString("\n") + "\n" + 
        """|    }
           |  }
           |  def fromChar(c: Char): Option[AlphaNum] = c match {
           |""".stripMargin('|') +
        chars.map { c =>
          s"    case '$c' => ${className(c)}.some"
        }.mkString("\n") + "\n" +
        """|    case other => none
           |  }
           |
           |  val allValues: List[AlphaNum] = List(
           |""".stripMargin('|') +
        chars.map { c =>
          s"    ${className(c)}"
        }.mkString(",\n") + ")\n" + 
        """|}
           |""".stripMargin('|') +
        chars.map { c =>
          s"case object ${className(c)} extends AlphaNum"
        }.mkString("\n") 

      IO.write(file, string)

      List(file)
    }

    val file = (sourceManaged in Compile).value / "model" / s"AlphaNum.scala"
    createAlphaNum(file)
  }

  lazy val ab = Project(
    id = "ab",
    base = file("."),
    settings = Project.defaultSettings ++ Seq(
      name := "ab",
      organization := "ab",
      version := "0.1-SNAPSHOT",
      scalaVersion := "2.11.5",
      scalacOptions ++= pedanticScalac,
      libraryDependencies ++= deps,
      resolvers ++= customResolvers,
      sourceGenerators in Compile += autoGenerated.taskValue
      // add other settings here
    )
  )
}
